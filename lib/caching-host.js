var _ = require('lodash');
var os = require('os');
var fs = require('fs');
var path = require('path');
var log = require('debuglog')(require('../package').name);
var ts = require('typescript');

function Host() {
	this.input = {};
	this.output = {};

	this.cachedInput = {};
	this.cachedOutput = {};
	
	this.version = 0;
}

/**
 * Reset the current program being compiled
 *
 * @param {boolean} wheher to cache the output of the current program
 * @api public
 */

Host.prototype.reset = function (cacheOutput) {
	var self = this;

	if (cacheOutput) {
		// move all the just-compiled files to the cache
		_.keys(self.output, function(key) {
			self.cachedOutput[key] = self.output[key];
		});
	}

	this.input = {};
	this.output = {};
	++this.version;

	log('Resetting (version %d)', this.version);
};

/**
 * Returns the output files generated by the typescript compiler
 * Output files can include compiled javascript, declaration files and map files
 *
 * @returns {array} map of output files and their contents
 * @api public
 */
Host.prototype.getOutput = function () {
	return _.clone(this.output);
};

/**
 * Have any of the input files been modified since their output was cached?
 *
 * @param {array} list of input files with absolute paths
 * @return {object} compilation results
 * @api public
 */
Host.prototype.inputHasChanged = function () {
	return _.values(this.input)
		.some(function(entry) {
			if (entry.changed)
				log('file has changed (%s)', entry.filename);

			return entry.changed;
		});
};

/**
 * TypeScript calls this when it wants to write an output file
 *
 * @param {string} output file name
 * @param {string} contens of file
 * @api public
 */
Host.prototype.writeFile = function (filename, data) {
	var fixRequires = require('./fix-requires');

	log('Wrote file %s', filename);
	this.output[filename] = fixRequires(filename, data);
};

/**
 * TypeScript calls this when it wants to read an input file
 *
 * @param {string} input file name
 * @param {ScriptTarget} JavaScript version
 * @param {function} callback in the event of a file error
 * @api public
 */     
Host.prototype.getSourceFile = function (filename, languageVersion, onError) {
	var normalized = ts.normalizePath(filename);

	if (this.input[normalized])
		return this.input[normalized].ts;

	var mtime = this.getMtime(filename, onError);

	if (this.cachedInput[normalized] && (this.cachedInput[normalized].mtime.getTime() == mtime.getTime())) {
		log('Reused file %s (version %s)', normalized, file.version);
		this.cachedInput[normalized].changed = false;
	}
	else {
		var text = this.readFile(filename, onError);

		file = ts.createSourceFile(filename, text, languageVersion, this.version.toString());	
		log('New version of source file %s (version %s)', normalized, file.version);

		this.cachedInput[normalized] = {
			"filename": filename,
			"ts": file,
			"mtime": mtime,
			"changed": true
		};
	}

	this.input[normalized] = this.cachedInput[normalized];
	return this.cachedInput[normalized].ts;
}

/**
 * Returns the modified time of the file or calls the callback and throws an error
 *
 * @param {string} input file name
 * @param {function} callback in the event of a file error
 * @returns {Date} modified time of the file
 * @api public
 */     
Host.prototype.getMtime = function (filename, onError) {
	try {
		var stat = fs.statSync(filename);
		return stat.mtime;
	}
	catch (err) {
		onError(err);
		return 0;
	}
}

/**
 * Returns the contents of the file or calls the callback and throws an error
 *
 * @param {string} input file name
 * @param {function} callback in the event of a file error
 * @returns {string} contents of the file
 * @api public
 */     
Host.prototype.readFile = function (filename, onError) {
	try {
		return fs.readFileSync(filename, 'utf-8');
	} 
	catch (err) {
		onError(err);
		return "";
	}
}

/* Standard Host functions */
Host.prototype.getNewLine = function () {
	return os.EOL;
};

Host.prototype.useCaseSensitiveFileNames = function () {
	var platform = os.platform();
	return platform !== 'win32' && platform !== 'win64' && platform !== 'darwin';
};

Host.prototype.getCurrentDirectory = function () {
	return this.currentDirectory;
};

Host.prototype.getCanonicalFileName = function (filename) {
	return ts.normalizePath(filename);
};

Host.prototype.getDefaultLibFilename = function () {
	var tsdir = path.dirname(require.resolve('typescript'));
	return path.resolve(tsdir, 'lib.d.ts');
};

module.exports = Host;
